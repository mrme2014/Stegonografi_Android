package com.sample.stego_image;

/**
 * Created by timian on 2018/11/15.
 */

public class Test {
    public static void main(String[] args) {

//        String s = "message消息中文字符串二进制流弊不";
//        //用StringBuffer来存储一长串的字符串转换成的比特流
//        StringBuffer sb = new StringBuffer();
//        String s1 = "";
//        //获得字符串的字节码数组
//        byte[] b = s.getBytes();
//        int j = 1;
//
//        for (int i = 0; i < b.length; i++) {
//            //将字节数组转换成二进制
//            s1 = Integer.toBinaryString(b[i] & 0xff);
//            if (s1.length() < 8) {
//                s1 = "0" + s1;
//            }
//            System.out.println(j + "-----" + s1 + "--LEN:" + s1.length());
//            sb.append(s1);
//            j++;
//        }
//        System.out.println("1000的二进制"+Integer.toBinaryString(10));
//        System.out.println(sb);
//        getString(sb);
        System.out.println(0 & 0);
        System.out.println(0 & 1);
        System.out.println(Integer.toBinaryString(101 & 0xff));
        System.out.println(Integer.toBinaryString(100000 & 0xff));

        // transformIntTo32BitBinary(1000);
    }

    //用存储二进制字符的StringBuffer长生字符串
    public static void getString(StringBuffer sb) {
        //获得一串二进制字符
        StringBuffer buffer = sb;//new StringBuffer("0110110101100101011100110111001101100001011001110110010111100110101101101001000111101101100011000110101010100100111001100011111111010100111000101011111000110010010011101000110110111011011001001101101110000100101000110100101111001000010010010011001001001001011010111001100010000001010100111001010100001001000010011101100110111000110101010110110001110000000101011000110100101110111000010011100011000111001001011011000110001111111110101011001001010101110101011111110000001110001011011011011111111001001110001001000111000101010000101011111110000000001111010100100100000000111000001111000111000110101011111010100000001111110000001010101011010001110110111111111001000110111011010000100101111110000000000000100101010100000000110110000000110110111000100100000111000001110001110000001010100100101110001001000101011000111000111010101111000111111111111110000000101010100100000001000110101011001001000111010101111000111110001110001111111010100101011111110110111011010110111000111011010001000111110001110000000001010100100101111111001000100100111001000110100101110111000000000001110000001010100100100001110111000100101001000110110000000000111000000000000001110000101010101011110000110111010101000111000110001111111011010100101111111111111110000001111110001110001000111001001000110110110110100100101010001110001110001110000001110001111111000110111001000110110111001010100100101110000000001110000001110000000000000110111000111000111001000111011011011011110001111111110000000001111110000001000111001000111000111000110101010101010001110000000001110001110000001111110111000111001001000111000110101011011010001110000001110001111110001111110000111001001001000111001000111011010101010001110000001111111110001111111110000111001001000111001001001001010101011011110001110000000001111110001110001111001001001001001001001001000001111111110101011010101010101011010100101010100111000111001001000111000110000000000000000");
        //构造的字节数组长度仅为二进制字符流长度的1/8，否则空的字节数组部分会长生不必要的字符
        byte[] b = new byte[buffer.length() / 8];
        int j = 0, k = 0;
        //将二进制字符流七个一组地进行分割
        for (int i = 0; i < buffer.length(); i += 8) {
            j = i + 8;
            if (j > sb.length())
                break;
            System.out.println(buffer.substring(i, j));
            //用8个二进制字符构造一个字节并保存到字节数组中
            b[k++] = Integer.valueOf(buffer.substring(i, j), 2).byteValue();
        }
        //构造字符串并进行输出。
        System.out.println(new String(b));
    }


    private static String transformIntTo32BitBinary(int value) {
        char[] chs = new char[Integer.SIZE];
        for (int i = 0; i < Integer.SIZE; i++) {
            chs[Integer.SIZE - 1 - i] = (char) (((value >> i) & 1) + '0');
        }
        String s = new String(chs);
        System.out.println(s);
        System.out.println(Integer.toBinaryString(value));
        return s;
    }
}
